Rocket MQ
主从模式 多主多从
数据同步
Topic 多个消息队列 默认一个topic在一个broker上有4个消息队列
Tag 过滤消息使用
消费模式
集群消费 集群中只有一个broker节点能成功消费消息，消费失败之后有重试机制（Exception和连接 超时），衰减重试16次后，进入死信队列。
广播消费 能够保证消息至少被消费一次，消费失败之后没有重试机制
如何保证消息一定会被消费成功，消费者链路中？
消息重发机制
零拷贝原理 磁盘中的消息在内核态中直接发送，不用拷贝到用户空间后在发送，减少拷贝次数
消息存储
日志文件
索引文件
事务消息原理
Kafka
集群模式
数据同步机制
数据分区
数据副本
消息存储
日志文件
索引文件
消息消费机制
分区分配策略
range
随机
粘滞策略
rebalance原理
程序连接kafka的参数设置
生产者连接
消费者连接
————————————————
版权声明：本文为CSDN博主「态度决定高度，习惯主宰人生」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_42551200/article/details/109777624





2. 消息重复消费问题
   可能原因：发送时消息重复、投递时消息重复
   消费者的接口要实现等幂性
   方法一：全局唯一ID：根据业务的操作和内容生成一个全局ID，在执行操作前先根据这个全局唯一ID是否存在，来判断这个操作是否已经执行。
   方法二：去重表，建立一个去重表，去重表中设置唯一索引，如果去重表插入成功则执行
   方式三：多版本控制
3. activemq消息丢失如何处理
   情况一：发送到broker时消息丢失
   解决：先持久到数据库，发送成功后删除或者标记删除。定时任务处理

情况二：broker崩溃
解决：消息持久化

情况三：broker到消费端出问题
解决：逻辑整理使其可以重新发送（如，发送时持久化消息并置状态为已发送，消费成功则置为已消费），当然消费要实现等幂性
情况一：发送到broker时消息丢失
解决：先持久到数据库，发送成功后删除或者标记删除。定时任务处理

情况二：broker崩溃
解决：消息持久化

情况三：broker到消费端出问题
解决：逻辑整理使其可以重新发送（如，发送时持久化消息并置状态为已发送，消费成功则置为已消费），当然消费要实现等幂性

4. 消费顺序性如何保证
   方案一：保证需要排序的消息按照先后顺序发送到同一个消费队列中，并且这个队列只有一个相应的消费者
   方案二：通过业务限制，保证前消息被消费完，才可以发送后消息

————————————————
版权声明：本文为CSDN博主「ThisLX」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/li521wang/article/details/8933728、Activemq的作用以及原理

Activemq 的作用就是系统之间进行通信。 当然可以使用其他方式进行系统间通信， 如果使用 Activemq 的话可以对系统之间的调用进行解耦， 实现系统间的异步通信。 原理就是生产者生产消息， 把消息发送给activemq。 Activemq 接收到消息， 然后查看有多少个消费者， 然后把消息转发给消费者， 此过程中生产者无需参与。 消费者接收到消息后做相应的处理和生产者没有任何关系
