*
* java中==和equals和hashCode的区别
* int、char、long各占多少字节数
* int与integer的区别
* 探探对java多态的理解
* String、StringBuffer、StringBuilder区别
* 什么是内部类？内部类的作用
* 抽象类和接口区别
* 抽象类的意义
* 抽象类与接口的应用场景
* 抽象类是否可以没有方法和属性？
* 接口的意义
* 泛型中extends和super的区别
* 父类的静态方法能否被子类重写
* 进程和线程的区别
* final，finally，finalize的区别
* 序列化的方式
* Serializable 和Parcelable 的区别
* 静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？
* 静态内部类的设计意图
* 成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用
* 谈谈对kotlin的理解
* 闭包和局部内部类的区别
* string 转换成 integer的方式及原理

虚拟机运行时数据区

1. GC算法有哪些
2. 垃圾回收器有哪些
3. 如何调优JVM
4. w

方法区
堆
虚拟机栈
本地方法栈
程序计数器
类加载机制

装载
通过一个类的全限定名获取定义此类的二进制字节流；
将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 ；
在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。
链接
验证
文件格式验证
元数据验证
字节码验证
符号引用验证
准备
为类的静态变量分配内存，并将其初始化为默认值
解析
把类中的符号引用转换为直接引用
初始化
对类的静态变量，静态代码块执行初始化操作
类装载器

双亲委派机制的优点

防止重复加载
防止核心类不被篡改，保证数据安全
判断Java对象时候存活的算法

引用计数法
可达性分析算法
垃圾回收算法

垃圾收集器种类

吞吐量优先

停顿时间优先

CMS垃圾收集器的工作过程

CMS和G1的区别？

CMS

优点：并发收集、低停顿
缺点：产生大量空间碎 片、并发阶段会降低吞吐量
使用“标记-清除”算法
G1

并行与并发

分代收集（仍然保留了分代的概念）

空间整合（整体上属于“标记-整理”算法，不会导致空间碎片）

可预测的停顿（比CMS更先进的地方在于能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集

上的时间不得超过N毫秒）

Java中的对象一定都存储在堆中么（逃逸分析）

Java对象创建的过程？

生产上遇到OOM如何排查？

JVM启动参数-XX:+HeapDumpOnOutOfMemoryError，当OutOfMemoryError发生时自动生成 Heap Dump 文件；
或者通过jmap -heap 结合pid手动生成Heap Dump文件；
分析Dump文件，使用JDK自带的jvisualVm或者Eclipse memory analyzer等工具进行日志分析
可以查看哪些对象被平凡创建，哪些对象占用内存空间较大；
CPU占用100%如何分析原因？

查找pid
top 查看CPU占用率,找到消耗CPU最多的线程号 top -H -p pid
使用jsatck生成 Thread Dump文件
将线程号转化为16进制后查询日志
Java应用生产环境线程发生死锁的情况如何解决？

jstack
jconsole
JVM优化？

适当的增大堆内存大小
选择合适的垃圾收集器
G1合理设置停顿时间
合理设置并发线程数
调整启动并发GC时堆内存占用百分比
内存泄漏和内存溢出的区别，分别产生的原因，及解决方案
内存泄漏的原因：

代码缺陷，使用完对象后没有及时释放，导致某些不会再被使用的对象不能被垃圾回收器正常回收
内存泄漏解决方案：

使用完对象后将其置为NULL;
使用数据库连接，IO操作，网络连接后要关闭连接;
使用集合类后需要将其remove或置为NULL;
正确使用单例模式，如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收；
内存溢出的原因

内存泄漏到一定程度会导致内存溢出
创建大对象时，无法分配足够大的空间会导致内存溢出
应用程序并发较高时，
内存中加载的数据过多
在循环中不断创建实例对象
启动参数内存值设置过小·
内存溢出解决方案

代码检查
检查数据库查询语句，是否有一次获取全部数据的查询
根据应用程序QPS峰值，合理部署集群节点数，合理进行负载均衡
合理设置内存值大小，可根据峰值的请求量以及估算实例对象的大小，设置JVM启动参数内存值大小
频繁发生Full GC的原因，及解决方案？（老年代进行空间分配担保）

System.gc()方法的调用，强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可通过通过-XX:+ DisableExplicitGC来禁止RMI（Java远程方法调用）调用System.gc。
适当调整新生代的空间大小，让对象在新生代多存活一段时间，
适当增加方法区的大小
启用空间分配担保机制
执行Minor GC的时候，JVM会检查老年代中最大连续可用空间是否大于了当前新生代所有对象的总大小。

如果大于，则直接执行Minor GC（这个时候执行是没有风险的）。

如果小于了，JVM会检查是否开启了空间分配担保机制，如果没有开启则直接改为执行Full GC。

如果开启了，则JVM会检查老年代中最大连续可用空间是否大于了历次晋升到老年代中的平均大小，如果小于则执行改为执行Full GC。

如果大于则会执行Minor GC，如果Minor GC执行失败则会执行Full GC。

工具

jconsole
jvisualvm
MAT 分析Heap Dump文件
perfma 在线
GC Viewer 分析GC日志
gceasy 在线
JVM命令

jps
jinfo
jstat
jstack
jmap
CMS垃圾收集器的优化步骤

CMS收集器一般在内存使用空间占比达到某一比例的时候CMS 收集器就会被激活。现在默认比例一般90%以上
通过参数设置，整理空间碎片
G1垃圾收集器的优化步骤

适当调整内存大小
调整最大停顿时间
调整启动并发GC时堆内存占用百分比

多线程

* 哪些情况下的对象会被垃圾回收机制处理掉？
* 讲一下常见编码方式？
* utf-8编码中的中文占几个字节；int型几个字节？
* 静态代理和动态代理的区别，什么场景使用？
* Java的异常体系
* 谈谈你对解析与分派的认识。
* 修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法？
* Java中实现多态的机制是什么？
* 如何将一个Java对象序列化到文件里？
* 说说你对Java反射的理解
* 说说你对Java注解的理解
* 说说你对依赖注入的理解
* 说一下泛型原理，并举例说明
* Java中String的了解
* String为什么要设计成不可变的？
* Object类的equal和hashCode方法重写，为什么？

Java中多态的实现原理？

Java中线程池的工作原理？

ThreadLocal的使用场景和原理？

使用syncronized和Lock实现生产者消费者模式？

线程池如何正常关闭？

synchronized锁的升级过程？

synchronized重入锁和非公平锁的实现原理？

synchronized和Lock的区别？

synchronized为什么称之为重量级锁？

JUC（并发编程工具包）包下使用过哪些类？

阻塞队列的实现原理？

阻塞队列中的消息服务重启时，如何持久化？

AQS队列原理？

Lock的几种实现方式？

volatile关键字的使用场景和作用 （解决可见性和有序性）

1.解决可见性问题
2.禁止指令重排序

JMM关于synchronized的两条规定：（解决可见性和原子性）

1.线程解锁前，必须把共享变量的最新值刷新到主内存中;
2.线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值;（注意：加锁与解锁需要是同一把锁）
通过以上两点，可以看到synchronized能够实现可见性。同时，由于synchronized具有同步锁，所以它也具有原子性

volatile能当锁使用么？

简述JMM(Java内存模型)

ConcurrentHashMap的原理?

PriorityQueue(堆)?

BIO、NIO、AIO的区别？NIO中selector、poll、epoll模型的区别?

1.select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。
2. select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。

TCP协议、HTTP协议、https协议的原理？

TCP协议的滑动窗口？

常用的序列化协议及区别？

StringBuffer和SpringBuilder的区别，线程是否安全的原理？

ArrayList和LinkedList的区别？

重写equals方法的时候为什么要重写hasCode方法？

HashSet是如何实现去重功能的？HashMap怎么保证key不重复的？

HashMap的线程不安全体现在哪些地方？

1.数据丢失
2.数据覆盖
3.死循环

HashMap底层数据结构，为什么选择红黑树？

Java中为什么是单继承？

接口和抽象类的区别？

Java中多态的原理？

Java中类加载机制？

装载
链接
验证
准备
解析
初始化
Java中static关键字的作用?

修饰成员变量
修饰方法
修饰代码块
HashMap的扩容过程？

红黑树解决了什么问题

线程池如果关闭了两次会有什么问题？



虚拟机运行时数据区

1. GC算法有哪些
2. 垃圾回收器有哪些
3. 如何调优JVM
4. w

方法区
堆
虚拟机栈
本地方法栈
程序计数器
类加载机制

装载
通过一个类的全限定名获取定义此类的二进制字节流；
将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 ；
在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。
链接
验证
文件格式验证
元数据验证
字节码验证
符号引用验证
准备
为类的静态变量分配内存，并将其初始化为默认值
解析
把类中的符号引用转换为直接引用
初始化
对类的静态变量，静态代码块执行初始化操作
类装载器

双亲委派机制的优点

防止重复加载
防止核心类不被篡改，保证数据安全
判断Java对象时候存活的算法

引用计数法
可达性分析算法
垃圾回收算法

垃圾收集器种类

吞吐量优先

停顿时间优先

CMS垃圾收集器的工作过程

CMS和G1的区别？

CMS

优点：并发收集、低停顿
缺点：产生大量空间碎 片、并发阶段会降低吞吐量
使用“标记-清除”算法
G1

并行与并发

分代收集（仍然保留了分代的概念）

空间整合（整体上属于“标记-整理”算法，不会导致空间碎片）

可预测的停顿（比CMS更先进的地方在于能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集

上的时间不得超过N毫秒）

Java中的对象一定都存储在堆中么（逃逸分析）

Java对象创建的过程？

生产上遇到OOM如何排查？

JVM启动参数-XX:+HeapDumpOnOutOfMemoryError，当OutOfMemoryError发生时自动生成 Heap Dump 文件；
或者通过jmap -heap 结合pid手动生成Heap Dump文件；
分析Dump文件，使用JDK自带的jvisualVm或者Eclipse memory analyzer等工具进行日志分析
可以查看哪些对象被平凡创建，哪些对象占用内存空间较大；
CPU占用100%如何分析原因？

查找pid
top 查看CPU占用率,找到消耗CPU最多的线程号 top -H -p pid
使用jsatck生成 Thread Dump文件
将线程号转化为16进制后查询日志
Java应用生产环境线程发生死锁的情况如何解决？

jstack
jconsole
JVM优化？

适当的增大堆内存大小
选择合适的垃圾收集器
G1合理设置停顿时间
合理设置并发线程数
调整启动并发GC时堆内存占用百分比
内存泄漏和内存溢出的区别，分别产生的原因，及解决方案
内存泄漏的原因：

代码缺陷，使用完对象后没有及时释放，导致某些不会再被使用的对象不能被垃圾回收器正常回收
内存泄漏解决方案：

使用完对象后将其置为NULL;
使用数据库连接，IO操作，网络连接后要关闭连接;
使用集合类后需要将其remove或置为NULL;
正确使用单例模式，如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收；
内存溢出的原因

内存泄漏到一定程度会导致内存溢出
创建大对象时，无法分配足够大的空间会导致内存溢出
应用程序并发较高时，
内存中加载的数据过多
在循环中不断创建实例对象
启动参数内存值设置过小·
内存溢出解决方案

代码检查
检查数据库查询语句，是否有一次获取全部数据的查询
根据应用程序QPS峰值，合理部署集群节点数，合理进行负载均衡
合理设置内存值大小，可根据峰值的请求量以及估算实例对象的大小，设置JVM启动参数内存值大小
频繁发生Full GC的原因，及解决方案？（老年代进行空间分配担保）

System.gc()方法的调用，强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可通过通过-XX:+ DisableExplicitGC来禁止RMI（Java远程方法调用）调用System.gc。
适当调整新生代的空间大小，让对象在新生代多存活一段时间，
适当增加方法区的大小
启用空间分配担保机制
执行Minor GC的时候，JVM会检查老年代中最大连续可用空间是否大于了当前新生代所有对象的总大小。

如果大于，则直接执行Minor GC（这个时候执行是没有风险的）。

如果小于了，JVM会检查是否开启了空间分配担保机制，如果没有开启则直接改为执行Full GC。

如果开启了，则JVM会检查老年代中最大连续可用空间是否大于了历次晋升到老年代中的平均大小，如果小于则执行改为执行Full GC。

如果大于则会执行Minor GC，如果Minor GC执行失败则会执行Full GC。

工具

jconsole
jvisualvm
MAT 分析Heap Dump文件
perfma 在线
GC Viewer 分析GC日志
gceasy 在线
JVM命令

jps
jinfo
jstat
jstack
jmap
CMS垃圾收集器的优化步骤

CMS收集器一般在内存使用空间占比达到某一比例的时候CMS 收集器就会被激活。现在默认比例一般90%以上
通过参数设置，整理空间碎片
G1垃圾收集器的优化步骤

适当调整内存大小
调整最大停顿时间
调整启动并发GC时堆内存占用百分比
