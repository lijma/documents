6.1 乐观锁与悲观锁的区别？

6.2 事务的特性

6.3 不考虑事务的隔离性引发的一系列安全问题

6.4 mysql常用的数据库引擎

6.5 jdbc中Statement与Preparestament的区别

6.6 sql优化

6.7 分表分库

6.8 oracle数据库的分页

6.9 mysql索引的分类

6.10 创建索引的原则

6.11 mysql索引的工作原理

 

6.12 复制基本原理流程

6.13 MySQL复制的线程有几个及之间的关联

6.14 MySQL如何保证复制过程中数据一致性及减少数据同步延时

6.15 数据库主库和从库不一致,怎么解决？

6.16 MySQL存储引擎MyISAM与InnoDB区别 

6.17 索引如何提高查询效率？
————————————————
版权声明：本文为CSDN博主「hzau_itdog」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/hzau_itdog/article/details/86745671



事务隔离级别

脏读
不可重复读
幻读–如何解决
索引结构

聚簇索引

回表

主从数据同步

集群模式如何数据不丢失

SQL优化的具体步骤

Explain 查看执行计划

type类型最好为ref或者range，index和all需要优化

查看查询是否走索引

filtered：这个字段表示存储引擎返回的数据在 server 层过滤后，剩下多少满足查询的记录数

量的比例，它是一个百分比。

Extra

using index 使用到了覆盖索引

using where 使用了 where 过滤，表示存储引擎返回的记录并不是所有的都满足查询条件，需要

在 server 层进行过滤（跟是否使用索引没有关系）。

using index condition 索引条件下推 索引下推在非主键索引上的优化，可以有效减少回表的次数，大大提升了查询的效率。

using temporary 用到了临时表

关联查询的注意事项

小表驱动大表
左连接以左表为准
右连接以右表为准
哪些情况会使索引失效？

如果条件中有or，即使其中有部分条件带索引也不会使用(这也是为什么尽量少用or的原因)，要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引；
前导模糊查询不能利用索引（like ‘%xx’ 或者 like ‘%xx%’）
违反组合索引最左匹配原则
需要隐形类型装换（如数字转换成字符）
where 子句里对索引列上有数学运算，用不上索引
where 子句里对有索引列使用函数，用不上索引
如果mysql估计使用全表扫描要比使用索引快,则不使用索引
什么时候没有必要用索引？

唯一性差;
频繁更新的字段不用（更新索引消耗）;
where中不用的字段;
索引使用<>时，效果一般;
存储引擎InnoDB和MyISAM的区别

InnoDB支持事务，支持表级别锁和行级别锁，数据和索引绑定在一起
MyISAM不支持事务，只支持表级别锁，数据文件和索引文件分开存储
Mysql中页分裂的原理？

数据页结构

https://blog.csdn.net/qq_35045184/article/details/104346594

B+树和B树的区别？B+树的搜索原理？

B+树和B树的区别
B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。
B+ 树的优点在于：

IO次数更少：由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。
遍历更加方便：B+树的叶子结点都是相链的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。
但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。

为什么MySQL选择B+树做索引

1. B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。
2. B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
3. B+树更便于遍历：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。
4. B+树更适合基于范围的查询：B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。

数据结构中的各种树

https://www.cnblogs.com/maybe2030/p/4732377.html
Mysql中哪些情况下不会使用到索引？

如果条件中有or，即使其中有部分条件带索引也不会使用(这也是为什么尽量少用or的原因)
对于多列索引，不是使用的第一部分，则不会使用索引
like查询是以%开头
.存在索引列的数据类型隐形转换，则用不上索引，比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
where 子句里对索引列上有数学运算，用不上索引
where 子句里对有索引列使用函数，用不上索引
如果mysql估计使用全表扫描要比使用索引快,则不使用索引
limit和order的使用

1. 如果你只需要结果集中的某几行，那么建议使用limit。这样这样的话可以避免抓取全部结果集，然后再丢弃那些你不要的行。
2. 对于order by查询，带或者不带limit可能返回行的顺序是不一样的。
3. 如果limit *row_count* 与 order by 一起使用，那么在找到第一个***row_count***就停止排序，直接返回。
4. 如果order by列有相同的值，那么MySQL可以自由地以任何顺序返回这些行。换言之，只要order by列的值不重复，就可以保证返回的顺序。
5. 可以在order by子句中包含附加列，以使顺序具有确定性。

数据量过大时，对limit语句进行优化

MVCC的原理

MySQL中锁的种类及作用

binlog日志的存储格式有几种？

* sqlite升级，增加字段的语句
* 数据库框架对比和源码分析
* 数据库的优化
* 数据库数据迁移问题

6.1 乐观锁与悲观锁的区别？

6.2 事务的特性

6.3 不考虑事务的隔离性引发的一系列安全问题

6.4 mysql常用的数据库引擎

6.5 jdbc中Statement与Preparestament的区别

6.6 sql优化

6.7 分表分库

6.8 oracle数据库的分页

6.9 mysql索引的分类

6.10 创建索引的原则

6.11 mysql索引的工作原理

 

6.12 复制基本原理流程

6.13 MySQL复制的线程有几个及之间的关联

6.14 MySQL如何保证复制过程中数据一致性及减少数据同步延时

6.15 数据库主库和从库不一致,怎么解决？

6.16 MySQL存储引擎MyISAM与InnoDB区别 

6.17 索引如何提高查询效率？
